/*******************************************************************************
  * OscaR is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation, either version 2.1 of the License, or
  * (at your option) any later version.
  *
  * OscaR is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License  for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License along with OscaR.
  * If not, see http://www.gnu.org/licenses/lgpl-3.0.en.html
  ******************************************************************************/
/*******************************************************************************
  * Contributors:
  *     This code has been initially developed by CETIC www.cetic.be
  *         by Renaud De Landtsheer
  ******************************************************************************/

package oscar.cbls.core.draft.computation

import oscar.cbls.algo.quick.QList
import oscar.cbls.core.draft.propagation._

import scala.language.implicitConversions


class Store(debug:Boolean = false,
            guaranteedAcyclic:Boolean = true,
            dropStaticGraphAfterClose:Boolean = true)
  extends PropagationStructure(debug,
    guaranteedAcyclic,
    dropStaticGraphAfterClose)
    with Bulker {

  assert({System.err.println("You are using a CBLS store with asserts activated. It makes the engine slower. Recompile it with -Xdisable-assertions"); true})
  if(debug) System.err.println("OscaR.cbls is running in debug mode. It makes the engine slower.")


  // ////////////////////////////////////////////////////////////////////////////////////////////
  // registration procedures

  private[this] var variables:QList[AbstractVariable] = null

  def registerVariable(v:AbstractVariable):Unit = {
    require(!isClosed,"model is closed, cannot add variables")
    //ici on utilise des listes parce-que on ne peut pas utiliser des dictionnaires
    // vu que les variables n'ont pas encore recu leur unique ID.
    variables = QList(v,variables)
    registerPropagationElement(v)
  }

  def registerInvariant(i:Invariant):Unit = {
    require(!isClosed,"model is closed, cannot add invariant")
    registerPropagationElement(i)
  }

  // ////////////////////////////////////////////////////////////////////////////////////////////
  // solution management

  private[this] var privateDecisionVariables:QList[Variable] = null;

  def decisionVariables:QList[Variable] = {
    if(privateDecisionVariables == null){
      var currentVarPos = variables
      while(currentVarPos != null){
        val v:AbstractVariable = currentVarPos.head
        currentVarPos = currentVarPos.tail
        if (v.isDecisionVariable){
          privateDecisionVariables = QList(v.asInstanceOf[Variable],privateDecisionVariables)
        }
      }
    }
    privateDecisionVariables
  }

  /**To save the current value of the variables registered in the model
    * @param inputOnly if set to true (as by default) the solution will only contain the variables that are not derived through an invariant
    */
  def solution(inputOnly:Boolean = true):Solution = {
    val variablesToSave = if(inputOnly) {
      decisionVariables
    }else variables
    new Solution(variablesToSave.map(_.snapshot),this)
  }

  /**this is to be used as a backtracking point in a search engine
    * you can only save variables that are not controlled*/
  def solutionFor(vars:Iterable[Variable]):Solution = {
    new Solution(vars.map(_.snapshot),this)
  }

  // ////////////////////////////////////////////////////////////////////////////////////////////
 //Closing procedure

  private var toCallBeforeClose:List[(()=>Unit)] = List.empty

  def addToCallBeforeClose(toCallBeforeCloseProc : (()=>Unit)){
    toCallBeforeClose = (toCallBeforeCloseProc) :: toCallBeforeClose
  }

  override def close(){
    for (p <- toCallBeforeClose) p()
    toCallBeforeClose = null

    super.close()
    killBulker() //we won't create any new model artifacts, thus we can kill the bulker and free its memory
  }
}

/**This class contains a solution. It can be generated by a model, to store the state of the search, and restored.
  * it remains linked to the model, as it maintains references to the variables declared in the model.
  * you cannot pass it over a network connection for instance.
  * see methods getSolution and restoreSolution in [[oscar.cbls.core.computation.Store]]
  */
class Solution(saves:Iterable[AbstractVariableSnapShot],
               model:Store){

  //TODO: serialize/deserialize

  override def toString:String = {
    "Solution(\n" + saves.mkString(",\n\t") + "\n)"
  }

  def restoreDecisionVariables() {
    for(snapshot <- saves) snapshot.restoreIfDecisionVariable()
  }

  def apply(a:AbstractVariable):AbstractVariableSnapShot = saves.find(_.variable == a).get
}

