/*******************************************************************************
  * OscaR is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation, either version 2.1 of the License, or
  * (at your option) any later version.
  *
  * OscaR is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License  for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License along with OscaR.
  * If not, see http://www.gnu.org/licenses/lgpl-3.0.en.html
  ******************************************************************************/
/*******************************************************************************
  * Contributors:
  *     This code has been initially developed by CETIC www.cetic.be
  *         by Renaud De Landtsheer
  ******************************************************************************/

package oscar.cbls.core.draft.computation

import oscar.cbls.algo.quick.QList
import oscar.cbls.core.draft.propagation._

import scala.language.implicitConversions

class Store(debug:Boolean = false,
            guaranteedAcyclic:Boolean = true,
            dropStaticGraphAfterClose:Boolean = true)
  extends PropagationStructure(debug,
    guaranteedAcyclic,
    dropStaticGraphAfterClose)
    with Bulker {

  assert({System.err.println("You are using a CBLS store with asserts activated. It makes the engine slower. Recompile it with -Xdisable-assertions"); true})
  if(debug) System.err.println("OscaR.cbls is running in debug mode. It makes the engine slower.")

  // ////////////////////////////////////////////////////////////////////////////////////////////
  // registration procedures

  private[this] var variables:QList[Variable] = null
  private[this] var changingValuesNotVariables:QList[ChangingValue] = null

  def registerChangingValue(v:ChangingValue):Unit = {
    require(!isClosed,"model is closed, cannot add variables")
    //ici on utilise des listes parce-que on ne peut pas utiliser des dictionnaires
    // vu que les variables n'ont pas encore recu leur unique ID.
    v match{
      case v:Variable =>
        variables = QList(v,variables)
      case v:ChangingValue =>
        changingValuesNotVariables = QList(v,changingValuesNotVariables)
      case _ => throw new Error("unsupported type of ChangingValue")
    }

    registerPropagationElement(v)
  }

  //TODO: how to know that it is not a changingValue??
  def registerInvariant(i:Invariant):Unit = {
    require(!isClosed,"model is closed, cannot add invariant")
    registerPropagationElement(i)
  }

  // ////////////////////////////////////////////////////////////////////////////////////////////
  // solution management

  lazy val decisionVariables:QList[Variable] = {
    require(isClosed, "decision variables cannot be computed before model close")
    var currentVarPos:QList[Variable] = variables
    var toReturn:QList[Variable] = null
    while(currentVarPos != null){
      val v:Variable = currentVarPos.head
      currentVarPos = currentVarPos.tail
      if (!v.hasDefiningInvariant){
        toReturn= QList(v,toReturn)
      }
    }
    toReturn
  }

  /**To save the current value of the variables registered in the model
    * @param inputOnly if set to true (as by default) the solution will only contain the variables that are not derived through an invariant
    */
  def solution(inputOnly:Boolean = true):Solution = {
    val variablesToSave = if(inputOnly) {
      decisionVariables
    }else variables
    new Solution(variablesToSave.map(_.snapshot),this)
  }

  /**this is to be used as a backtracking point in a search engine
    * you can only save variables that are not controlled*/
  def solutionFor(vars:Iterable[Variable]):Solution = {
    new Solution(vars.map(_.snapshot),this)
  }

  // ////////////////////////////////////////////////////////////////////////////////////////////
 //Closing procedure

  private var toCallBeforeClose:List[()=>Unit] = List.empty

  def addToCallBeforeClose(toCallBeforeCloseProc : ()=>Unit){
    toCallBeforeClose = toCallBeforeCloseProc :: toCallBeforeClose
  }

  override def close(){
    for (p <- toCallBeforeClose) p()
    toCallBeforeClose = null

    super.close()
    killBulker() //we won't create any new model artifacts, so we kill the bulker and reclaim its large memory
  }
}

/**This class contains a solution. It can be generated by a model, to store the state of the search, and restored.
  * it remains linked to the model, as it maintains references to the variables declared in the model.
  * you cannot pass it over a network connection for instance.
  * see methods getSolution and restoreSolution in [[oscar.cbls.core.computation.Store]]
  */
class Solution(saves:Iterable[ChangingValueSnapshot],
               model:Store){

  override def toString:String = {
    "Solution(\n" + saves.mkString(",\n\t") + "\n)"
  }

  def restoreDecisionVariables() {
    for(snapshot <- saves) snapshot.restoreIfDecisionVariable()
  }

  def apply(a:ChangingValue):ChangingValueSnapshot = saves.find(_.changingValue == a).get
}

